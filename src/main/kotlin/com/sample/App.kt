/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.sample

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import io.ktor.client.HttpClient
import io.ktor.client.engine.apache.Apache
import io.ktor.client.features.ClientRequestException
import io.ktor.client.features.json.JacksonSerializer
import io.ktor.client.features.json.JsonFeature
import io.ktor.client.request.get
import io.ktor.client.request.post
import io.ktor.client.request.url
import io.ktor.http.ContentType
import io.ktor.http.Url
import io.ktor.http.contentType
import io.ktor.util.toByteArray
import kotlinx.coroutines.async
import kotlinx.coroutines.runBlocking
import java.nio.charset.Charset

data class ToDo(val id: Int, val userId: Int, val title: String, val completed: Boolean)
data class ToDont(val invalid: String)
@JsonIgnoreProperties(ignoreUnknown = true)
data class ToDoException(val id: String? = null)

class App {

    val client = HttpClient(Apache) {
        install(JsonFeature) {
            serializer = JacksonSerializer()
        }
    }

    suspend fun queryToDo(id: Int) =
        client.get<ToDo> {
            url(Url("https://jsonplaceholder.typicode.com/todos/$id"))
        }

    suspend fun createTodo() =

        client.post<ToDo> {
            url(Url("https://jsonplaceholder.typicode.com/todos"))
            contentType(ContentType.Application.Json)
            body = ToDo(4, 100, "Title", true)
        }


}

fun main(args: Array<String>) {

    val objectMapper = ObjectMapper()

    // per PR comments, mark the function as suspend and hold any runBlocking until you need it
    // otherwise, you're needlessly blocking a thread.
    // This might make next to no difference for your use case.
    runBlocking {

        async {
            println("Start good query")
            App().queryToDo(1)
        }

        async {
            println("Start non-existent query")

            try {
                App().queryToDo(400)
            } catch (ex: ClientRequestException) {

                val response = ex.response.content.toByteArray().toString(Charset.forName("UTF-8"))
                println("Response is $response")
                // apparently you can't do this part cleanly
                println(objectMapper.readValue<ToDoException>(response))
                println(ex.message)
            }
        }

        async {
            println("Start create")
            println("Create: ${App().createTodo()}")
        }

    }

}
